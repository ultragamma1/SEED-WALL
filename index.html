<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SEED WALL â€” Plant a Seed</title>

<script>
/*
  CONFIG
  - SCROLL_SPEED is px/sec
  - Set PROXY to your serverless endpoint (recommended) or "" to try without proxy.
*/
const CONFIG = {
  SHEET_URL: "https://docs.google.com/spreadsheets/d/e/2PACX-1vSML6gg1Dtto69p2UZi3Aitf-Ke-z8ZE0ar_CwNRbywc8fPjh2ty5XMWlacaxrDQqNjfoFlU9pRvQRb/pubhtml?gid=218057891&single=true",
  PROXY: "",  // e.g. "/.netlify/functions/proxy?url=" or "" to attempt direct fetch
  HEADER_TEXT: "ðŸ”´ Plant A SEED - Recognize someone",
  SCROLL_SPEED: 40,
  FONT_SIZE: "32px",
  LEFT_MARGIN: "0px",
  AUTO_REFRESH_MS: 5000,
  MAX_COMMENTS: 350,
  REPEATS_PER_COMMENT: 2
};
</script>

<style>
:root { --font-size:32px; --left-margin:0px; --header-height:80px; }
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;font-family:Segoe UI,Arial,sans-serif;background:linear-gradient(135deg,#667eea,#764ba2);font-size:var(--font-size)}
.header{position:fixed;top:0;left:0;right:0;height:var(--header-height);background:#283266;color:#fff;text-align:center;line-height:var(--header-height);font-weight:700;z-index:1000;box-shadow:0 4px 20px rgba(0,0,0,.3)}
.app{padding-top:calc(var(--header-height)+20px);padding-left:var(--left-margin);min-height:calc(100vh - var(--header-height));display:flex;justify-content:center}
.scroller{width:min(1100px,95%);max-width:1200px;background:rgba(255,255,255,0.95);border-radius:8px;padding:24px;box-shadow:0 15px 50px rgba(0,0,0,.35);position:relative;height:calc(100vh - var(--header-height) - 40px);overflow:hidden}
.viewport{width:100%;height:100%;overflow:hidden;position:relative}
.scroll-content{position:absolute;top:0;left:0;right:0;will-change:transform}
.comment-list{display:flex;flex-direction:column;gap:12px}
.comment{padding:32px;border-radius:8px;background:#fff;box-shadow:0 4px 14px rgba(0,0,0,.06);color:#222;font-size:1.2rem;line-height:1.5;text-align:center}
.status{position:absolute;right:12px;top:12px;font-size:.85rem;background:rgba(0,0,0,.06);padding:6px 10px;border-radius:6px}

/* Animation placeholder; keyframes will be injected dynamically */
@keyframes scrollAnim { from { transform: translateY(0); } to { transform: translateY(calc(var(--singleHeight) * -1px)); } }

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .scroller{overflow:auto}
  .viewport,.scroll-content{transform:none !important;transition:none !important;will-change:auto !important}
}
</style>
</head>
<body>
  <div class="header" id="header" role="banner"></div>
  <main class="app" role="main">
    <section class="scroller" id="scroller" aria-label="Seed wall comments">
      <div class="status" id="status">Loadingâ€¦</div>
      <div class="viewport" id="viewport" aria-live="polite">
        <div class="scroll-content" id="scrollContent" aria-hidden="false"></div>
      </div>
    </section>
  </main>

<script>
document.documentElement.style.setProperty('--font-size', CONFIG.FONT_SIZE);
document.documentElement.style.setProperty('--left-margin', CONFIG.LEFT_MARGIN);
document.getElementById('header').textContent = CONFIG.HEADER_TEXT;

const viewport = document.getElementById('viewport');
const scrollContent = document.getElementById('scrollContent');
const statusEl = document.getElementById('status');
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

let retryDelay = 1000;
let singleHeight = 0;
let dynamicKeyframeId = 'dynamic-scroll-keyframes';

/* Build fetch URL (proxy optional) */
function buildFetchUrl() {
  const t = Date.now();
  const sheetUrlWithT = CONFIG.SHEET_URL + (CONFIG.SHEET_URL.includes('?') ? '&' : '?') + 't=' + t;
  return CONFIG.PROXY && CONFIG.PROXY.trim() !== '' ? (CONFIG.PROXY + encodeURIComponent(sheetUrlWithT)) : sheetUrlWithT;
}

/* Parse sheet HTML -> comments */
function parseCommentsFromHtml(htmlText) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlText, 'text/html');
  const tables = doc.querySelectorAll('table');
  const comments = [];
  if (!tables.length) return comments;
  const rows = tables[0].querySelectorAll('tr');
  rows.forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length > 1) {
      const text = cells[1].textContent.trim();
      if (text) comments.push(text);
    }
  });
  return comments;
}

/* Render comments, duplicate list, then apply animation */
function renderComments(comments) {
  // build single column
  const single = document.createElement('div');
  single.className = 'comment-list single';
  const frag = document.createDocumentFragment();
  if (!comments || !comments.length) {
    const el = document.createElement('div'); el.className = 'comment'; el.textContent = 'No comments yet â€” submit via QR code!'; frag.appendChild(el);
  } else {
    comments.slice(0, CONFIG.MAX_COMMENTS).forEach(c => {
      for (let i=0;i<(CONFIG.REPEATS_PER_COMMENT||1);i++){
        const e = document.createElement('div'); e.className='comment'; e.textContent = c; frag.appendChild(e);
      }
    });
  }
  single.appendChild(frag);

  // replace content and duplicate
  scrollContent.innerHTML = '';
  scrollContent.appendChild(single);
  const clone = single.cloneNode(true);
  scrollContent.appendChild(clone);

  // Wait until layout is stable: fonts and images may change height
  // Use document.fonts.ready if available, then measure in rAF
  const afterFonts = (window.document.fonts && document.fonts.ready) ? document.fonts.ready : Promise.resolve();
  afterFonts.then(() => {
    // Ensure layout complete on next frame
    requestAnimationFrame(() => {
      const rect = single.getBoundingClientRect();
      singleHeight = rect.height;
      console.log('measured singleHeight=', singleHeight, 'viewportH=', viewport.clientHeight);
      if (singleHeight <= viewport.clientHeight || prefersReducedMotion) {
        // stop animation; center/top as desired
        applyAnimation(false);
        scrollContent.style.transform = 'translateY(0)';
        viewport.style.overflow = prefersReducedMotion ? 'auto' : 'hidden';
      } else {
        viewport.style.overflow = 'hidden';
        applyAnimation(true);
      }
    });
  });
}

/* Apply or remove CSS animation (CSS keyframe) */
function applyAnimation(enable) {
  // remove any existing dynamic style
  const existing = document.getElementById(dynamicKeyframeId);
  if (existing) existing.remove();

  scrollContent.style.animation = 'none';
  if (!enable) return;

  // create dynamic keyframe CSS that translates by -singleHeight px
  const duration = singleHeight / CONFIG.SCROLL_SPEED; // seconds
  const css = `
    @keyframes dynamicScroll {
      from { transform: translateY(0); }
      to   { transform: translateY(-${singleHeight}px); }
    }
  `;
  const styleEl = document.createElement('style');
  styleEl.id = dynamicKeyframeId;
  styleEl.textContent = css;
  document.head.appendChild(styleEl);

  // apply animation: linear, infinite. Use translate3d for GPU
  scrollContent.style.animation = `dynamicScroll ${duration}s linear infinite`;
  scrollContent.style.willChange = 'transform';
}

/* Fetch + retry */
async function loadComments() {
  const url = buildFetchUrl();
  statusEl.textContent = 'Loadingâ€¦';
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('Network response not ok: ' + res.status);
    const html = await res.text();
    const comments = parseCommentsFromHtml(html);
    renderComments(comments);
    retryDelay = 1000;
    statusEl.textContent = 'Updated ' + new Date().toLocaleTimeString();
  } catch (err) {
    console.error('Error fetching sheet:', err);
    statusEl.textContent = 'Temporary loading issue â€” retryingâ€¦';
    setTimeout(loadComments, retryDelay);
    retryDelay = Math.min(retryDelay * 2, 60000);
  }
}

/* Start polling */
loadComments();
setInterval(loadComments, CONFIG.AUTO_REFRESH_MS);

/* Responsiveness: if viewport resized, re-measure and reapply animation */
let resizeTimer = null;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    // If we have content, re-measure the single list height and reapply
    const single = document.querySelector('.comment-list.single');
    if (single) {
      requestAnimationFrame(() => {
        singleHeight = single.getBoundingClientRect().height;
        if (singleHeight <= viewport.clientHeight || prefersReducedMotion) {
          applyAnimation(false);
        } else {
          applyAnimation(true);
        }
      });
    }
  }, 250);
});

/* React to reduced-motion changes */
const mm = window.matchMedia('(prefers-reduced-motion: reduce)');
mm.addEventListener && mm.addEventListener('change', (e) => {
  if (e.matches) {
    applyAnimation(false);
    viewport.style.overflow = 'auto';
  } else {
    // re-evaluate if we should animate
    const single = document.querySelector('.comment-list.single');
    if (single) {
      singleHeight = single.getBoundingClientRect().height;
      if (singleHeight > viewport.clientHeight) applyAnimation(true);
    }
  }
});
</script>
</body>
</html>
